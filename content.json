{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"kubeedge源码分析(一).md","slug":"kubeedge源码分析(一)","date":"2021-01-05T12:50:20.798Z","updated":"2021-01-05T12:51:54.052Z","comments":true,"path":"2021/01/05/kubeedge源码分析(一)/","link":"","permalink":"http://example.com/2021/01/05/kubeedge%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/","excerpt":"","text":"源码分析 组件名 组件功能 edge_mesh 服务网格解决方案 edge_site 边缘独立集群解决方案 mappers 物联网协议实现包 keadm kubeedge的一键部署工具 组件名 代码目录 组件启动入口 cloudcore kubeedge/cloud kubeedge/cloud/cmd/cloudcore/cloudcore.go，kubeedge/cloud/cmd/admission/admission.go，kubeedge/cloud/cmd/csidriver/csidriver.go edgecore kubeedge/edge kubeedge/edge/cmd/edgecore/edgecore.go edge_mesh kubeedge/edgemesh kubeedge/edgemesh/cmd/edgemesh.go edge_site kubeedge/edgesite kubeedge/edgesite/cmd/edgesite.go cloudcore源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445func main() &#123; command := app.NewCloudCoreCommand() //cobra调用新建函数 logs.InitLogs() defer logs.FlushLogs() if err := command.Execute(); err != nil &#123; os.Exit(1) &#125;&#125;-------------------------- app.NewCloudCoreCommand()func NewCloudCoreCommand() *cobra.Command &#123; opts := options.NewCloudCoreOptions() cmd := &amp;cobra.Command&#123; Use: &quot;cloudcore&quot;, Long: ..., Run: func(cmd *cobra.Command, args []string) &#123; ... config, err := opts.Config() ... registerModules(config) //注册cloudcore的功能模块 ... core.Run() //启动所有注册模版 &#125;, &#125; ... return cmd&#125;-------------------------- registerModules(config)// registerModules register all the modules started in cloudcorefunc registerModules(c *v1alpha1.CloudCoreConfig) &#123; cloudhub.Register(c.Modules.CloudHub, c.KubeAPIConfig) edgecontroller.Register(c.Modules.EdgeController, c.KubeAPIConfig, &quot;&quot;, false) devicecontroller.Register(c.Modules.DeviceController, c.KubeAPIConfig) synccontroller.Register(c.Modules.SyncController, c.KubeAPIConfig) cloudstream.Register(c.Modules.CloudStream)&#125;-------------------------- core.Run()// Run starts the modules and in the end does module cleanupfunc Run() &#123; // Address the module registration and start the core StartModules() // monitor system signal and shutdown gracefully GracefulShutdown()&#125; 总结上面代码，通过cobra自动启动NewCloudCoreCommand，把所有模块注册到registerModules，使用Run函数启动 edgecore源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970func main() &#123; command := app.NewEdgeCoreCommand() //cobra调用新建函数 logs.InitLogs() defer logs.FlushLogs() if err := command.Execute(); err != nil &#123; os.Exit(1) &#125;&#125;-------------------------- app.NewEdgeCoreCommand()func NewEdgeCoreCommand() *cobra.Command &#123; opts := options.NewEdgeCoreOptions() cmd := &amp;cobra.Command&#123; Use: &quot;edgecore&quot;, Long: ..., Run: func(cmd *cobra.Command, args []string) &#123; ... config, err := opts.Config() ... // Check the running environment by default checkEnv := os.Getenv(&quot;CHECK_EDGECORE_ENVIRONMENT&quot;) if checkEnv != &quot;false&quot; &#123; // Check running environment before run edge core if err := environmentCheck(); err != nil &#123; klog.Fatal(fmt.Errorf(&quot;Failed to check the running environment: %v&quot;, err)) &#125; &#125; // get edge node local ip if config.Modules.Edged.NodeIP == &quot;&quot; &#123; hostnameOverride, err := os.Hostname() if err != nil &#123; hostnameOverride = constants.DefaultHostnameOverride &#125; localIP, _ := util.GetLocalIP(hostnameOverride) config.Modules.Edged.NodeIP = localIP &#125; registerModules(config) //edgecore注册模块 // start all modules core.Run() &#125;, &#125; ... return cmd&#125;-------------------------- 同理注册模块 registerModules(config)func registerModules(c *v1alpha1.EdgeCoreConfig) &#123; devicetwin.Register(c.Modules.DeviceTwin, c.Modules.Edged.HostnameOverride) edged.Register(c.Modules.Edged) edgehub.Register(c.Modules.EdgeHub, c.Modules.Edged.HostnameOverride) eventbus.Register(c.Modules.EventBus, c.Modules.Edged.HostnameOverride) edgemesh.Register(c.Modules.EdgeMesh) metamanager.Register(c.Modules.MetaManager) servicebus.Register(c.Modules.ServiceBus) edgestream.Register(c.Modules.EdgeStream, c.Modules.Edged.HostnameOverride, c.Modules.Edged.NodeIP) test.Register(c.Modules.DBTest) // Note: Need to put it to the end, and wait for all models to register before executing dbm.InitDBConfig(c.DataBase.DriverName, c.DataBase.AliasName, c.DataBase.DataSource)&#125;-------------------------- core.Run()// Run starts the modules and in the end does module cleanupfunc Run() &#123; // Address the module registration and start the core StartModules() // monitor system signal and shutdown gracefully GracefulShutdown()&#125; edgemesh.Register模块已经整合到registerModules里面去了 edgesite源码分析123456789101112131415161718192021222324252627282930313233func main() &#123; command := app.NewEdgeSiteCommand() //创建 logs.InitLogs() defer logs.FlushLogs() if err := command.Execute(); err != nil &#123; os.Exit(1) &#125;&#125;func NewEdgeSiteCommand() *cobra.Command &#123; opts := options.NewEdgeSiteOptions() cmd := &amp;cobra.Command&#123; Use: &quot;edgesite&quot;, Long: ..., Run: func(cmd *cobra.Command, args []string) &#123; ... registerModules(config) //注册 // start all modules core.Run() //激活 &#125;, &#125; ... return cmd&#125;func registerModules(c *v1alpha1.EdgeSiteConfig) &#123; edged.Register(c.Modules.Edged) edgecontroller.Register(c.Modules.EdgeController, c.KubeAPIConfig, c.Modules.Edged.HostnamgieOverride, true) metamanager.Register(c.Modules.MetaManager) // Nodte: Need to put it to the end, and wait for all models to register before executing dbm.InitDBConfig(c.DataBase.DriverName, c.DataBase.AliasName, c.DataBase.DataSource)&#125; 共用框架beehive 以下注册运行模块(edgecore/cloudcore/edgemesh)代码一致性很高，我就单分析cloudcore另外两个的逻辑也是一样的。 看看Register函数做了些什么 123456789101112131415161718192021222324252627282930313233func Register(hub *v1alpha1.CloudHub, kubeAPIConfig *v1alpha1.KubeAPIConfig) &#123; hubconfig.InitConfigure(hub, kubeAPIConfig) core.Register(newCloudHub(hub.Enable)) //使用框架进行注册操作&#125;-------------进到Registertype Module interface &#123; Name() string Group() string Start() Enable() bool&#125;var ( // Modules map modules map[string]Module disabledModules map[string]Module)func init() &#123; modules = make(map[string]Module) disabledModules = make(map[string]Module)&#125;// Register register modulefunc Register(m Module) &#123; if m.Enable() &#123; modules[m.Name()] = m klog.Infof(&quot;Module %v registered successfully&quot;, m.Name()) &#125; else &#123; disabledModules[m.Name()] = m klog.Warningf(&quot;Module %v is disabled, do not register&quot;, m.Name()) &#125;&#125; 可以看到modules是一个map，Module是一个接口，里面有一个方法。Register的作用就是把Module接口放到全局变量modules中。 再看看core.Run()的方法。 1234567// Run starts the modules and in the end does module cleanupfunc Run() &#123; // Address the module registration and start the core StartModules() // monitor system signal and shutdown gracefully GracefulShutdown()&#125; 追到StartModules 1234567891011121314151617181920// StartModules starts modules that are registeredfunc StartModules() &#123; beehiveContext.InitContext(beehiveContext.MsgCtxTypeChannel) modules := GetModules() for name, module := range modules &#123; //Init the module beehiveContext.AddModule(name) //Assemble typeChannels for sendToGroup beehiveContext.AddModuleGroup(name, module.Group()) go module.Start() klog.Infof(&quot;Starting module %v&quot;, name) &#125;&#125;// GetModules gets modules mapfunc GetModules() map[string]Module &#123; return modules&#125; StartModules 功能：循环遍历register的modul并加入到beehiveContext里面去。gorotine start方法启动所有module插件。 1234567891011121314151617// GracefulShutdown is if it gets the special signals it does modules cleanupfunc GracefulShutdown() &#123; c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGILL, syscall.SIGTRAP, syscall.SIGABRT) select &#123; case s := &lt;-c: klog.Infof(&quot;Get os signal %v&quot;, s.String()) //Cleanup each modules beehiveContext.Cancel() modules := GetModules() for name, _ := range modules &#123; klog.Infof(&quot;Cleanup module %v&quot;, name) beehiveContext.Cleanup(name) &#125; &#125;&#125; GracefulShutdown功能：如果设置了signals，就把该modules清除掉。","categories":[],"tags":[]},{"title":"github图片如何显示出来","slug":"github图片不能显示","date":"2021-01-05T08:36:47.237Z","updated":"2021-01-05T08:46:13.650Z","comments":true,"path":"2021/01/05/github图片不能显示/","link":"","permalink":"http://example.com/2021/01/05/github%E5%9B%BE%E7%89%87%E4%B8%8D%E8%83%BD%E6%98%BE%E7%A4%BA/","excerpt":"","text":"对于我这个一天不登github就心慌的人来说，github图片不能显示，是一个大问题。 主要原因dns污染。 解决方法，配置本地hosts文件解决，中国区dns污染问题 mac电脑 终端输入sudo vi /etc/hosts。把下面内容添加进去 123456789101112131415161718# GitHub Start192.30.253.112 Build software better, together192.30.253.119 gist.github.com151.101.184.133 assets-cdn.github.com151.101.184.133 raw.githubusercontent.com151.101.184.133 gist.githubusercontent.com151.101.184.133 cloud.githubusercontent.com151.101.184.133 camo.githubusercontent.com151.101.184.133 avatars0.githubusercontent.com151.101.184.133 avatars1.githubusercontent.com151.101.184.133 avatars2.githubusercontent.com151.101.184.133 avatars3.githubusercontent.com151.101.184.133 avatars4.githubusercontent.com151.101.184.133 avatars5.githubusercontent.com151.101.184.133 avatars6.githubusercontent.com151.101.184.133 avatars7.githubusercontent.com151.101.184.133 avatars8.githubusercontent.com# GitHub End 保存退出，登陆github刷新就可以显示图片了","categories":[],"tags":[]},{"title":"kubeedge 核心架构组件详解","slug":"kubeedge笔记详解","date":"2021-01-05T03:24:22.448Z","updated":"2021-01-05T12:52:27.600Z","comments":true,"path":"2021/01/05/kubeedge笔记详解/","link":"","permalink":"http://example.com/2021/01/05/kubeedge%E7%AC%94%E8%AE%B0%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"kubeedge分为两个可执行程序（cloudcore/edgecore）- 8个组件cloudcore: CloudHub：云中的通信接口模块。 EdgeController：管理Edge节点。 devicecontroller 负责设备管理。 edgecore: Edged：在边缘管理容器化的应用程序。 EdgeHub：Edge上的通信接口模块。 EventBus：使用MQTT处理内部边缘通信。 DeviceTwin：它是用于处理设备元数据的设备的软件镜像。 MetaManager：它管理边缘节点上的元数据。 Edged详解： 和kubelet的功能相似。从metamanager接收和处理pod 保留config map和secrets的缓存 其他： CRI边缘化 container/images GC volume管理 各模块详解 eventbus 主要用来发送接收mqtt的消息接口（如蓝牙设备等等） 三种模式 internalMqttMode/externalMqttMode/bothMqttMode metamanager MetaManager是edged和edgehub之间的消息处理器。它还负责将元数据存储到轻量级数据库（SQLite）或从中检索元数据。 因为连接SQLite，所以能进行CRUD操作 Edgehub Edge Hub使用Web socket或QUIC协议和CloudHub组件进行交互。同步云端更新和报告边缘端主机状态 DeviceTwin 负责存储设备状态，处理设备属性，处理设备孪生操作，在边缘设备和边缘节点之间创建成员资格，将设备状态同步到云以及在边缘和云之间同步设备孪生信息。它还为应用程序提供查询接口。 由4个子模块组成：membership，communication，device和device twin 以下为云上组件 Edge Controller EdgeController是Kubernetes Api服务器和Edgecore之间的桥梁 CloudHub CloudHub是cloudcore的一个模块，是Controller和Edge端之间的中介。它同时支持基于Web套接字的连接以及QUIC协议访问。 功能：启用边缘与控制器之间的通信 Device Controller k8s CRD来描述设备metadata/status ，devicecontroller在云和边缘之间同步，有两个goroutines: upstream controller/downstream controller","categories":[],"tags":[]},{"title":"dockerfile","slug":"dockerfile","date":"2021-01-04T07:36:23.000Z","updated":"2021-01-04T07:40:35.076Z","comments":true,"path":"2021/01/04/dockerfile/","link":"","permalink":"http://example.com/2021/01/04/dockerfile/","excerpt":"","text":"dockerfile构建镜像1234567891011121314151617FROM alpine:latestADD etcd /usr/local/bin/ADD etcdctl /usr/local/bin/RUN mkdir -p /var/etcd/RUN mkdir -p /var/lib/etcd/# Alpine Linux doesn&#x27;t use pam, which means that there is no /etc/nsswitch.conf,# but Golang relies on /etc/nsswitch.conf to check the order of DNS resolving# (see https://github.com/golang/go/commit/9dee7771f561cf6aee081c0af6658cc81fac3918)# To fix this we just create /etc/nsswitch.conf and add the following line:RUN echo &#x27;hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4&#x27; &gt;&gt; /etc/nsswitch.confEXPOSE 2379 2380# Define default command.CMD [&quot;/usr/local/bin/etcd&quot;] 构建镜像 docker build -t etcd .","categories":[],"tags":[]},{"title":"docker启动etcd","slug":"docker启动etcd","date":"2021-01-03T14:48:22.000Z","updated":"2021-01-04T08:48:48.793Z","comments":true,"path":"2021/01/03/docker启动etcd/","link":"","permalink":"http://example.com/2021/01/03/docker%E5%90%AF%E5%8A%A8etcd/","excerpt":"","text":"启动服务docker run -p 2379:2379 -p 2380:2380 –name etcd-gcr-v3.4.0 quay.io/coreos/etcd:v3.4.0 /usr/local/bin/etcd –name s1 –data-dir /etcd-data –listen-client-urls http://0.0.0.0:2379 –advertise-client-urls http://0.0.0.0:2379 –listen-peer-urls http://0.0.0.0:2380 –initial-advertise-peer-urls http://0.0.0.0:2380 –initial-cluster s1=http://0.0.0.0:2380 –initial-cluster-token tkn –initial-cluster-state new –log-level info –logger zap –log-outputs stderr 我遇到的坑 默认启动都是localhost，结果外部访问不能访问","categories":[],"tags":[]},{"title":"go-zero脚手架搭建微服务笔记","slug":"go-zero微服务搭建笔记","date":"2021-01-03T07:02:38.491Z","updated":"2021-01-03T14:33:13.552Z","comments":true,"path":"2021/01/03/go-zero微服务搭建笔记/","link":"","permalink":"http://example.com/2021/01/03/go-zero%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"准备环境 安装etcd mysql redis 我都是放在docker里的，如下图所示docker pull gotok8s/etcd:3.3.10 安装protoc-gen-go 和 goctl工具 go get -u github.com/golang/protobuf/protoc-gen-gogo get -u github.com/tal-tech/go-zero/tools/goctl 生成目录 goctl api -o bookstore.api1Done. 显示上面提示说明成功生成 编写api文档 1234567891011121314151617181920212223242526272829type ( addReq &#123; book string &#96;form:&quot;book&quot;&#96; price int64 &#96;form:&quot;price&quot;&#96; &#125; addResp &#123; ok bool &#96;json:&quot;ok&quot;&#96; &#125;)type ( checkReq &#123; book string &#96;form:&quot;book&quot;&#96; &#125; checkResp &#123; found bool &#96;json:&quot;found&quot;&#96; price int64 &#96;json:&quot;price&quot;&#96; &#125;)service bookstore-api &#123; @handler AddHandler get &#x2F;add (addReq) returns (addResp) @handler CheckHandler get &#x2F;check (checkReq) returns (checkResp)&#125; 编写完上面内容，启动生成命令 goctl api go -api bookstore.api -dir . 启动测试服务 go run bookstore.go -f etc/bookstore-api.yaml 访问结果 123456curl -i &quot;http:&#x2F;&#x2F;localhost:8888&#x2F;check?book&#x3D;go-zero&quot;HTTP&#x2F;1.1 200 OKContent-Type: application&#x2F;jsonDate: Sun, 03 Jan 2021 07:46:30 GMTContent-Length: 25&#123;&quot;found&quot;:false,&quot;price&quot;:0&#125; 编写rpc服务（ADD服务） 创建rpc目录，进入目录 goctl rpc template -o add.proto 生成模版 在文件夹中编写add.proto 12345678910111213141516syntax &#x3D; &quot;proto3&quot;;package add;message addReq &#123; string book &#x3D; 1; int64 price &#x3D; 2;&#125;message addResp &#123; bool ok &#x3D; 1;&#125;service adder &#123; rpc add(addReq) returns(addResp);&#125; goctl rpc proto -src add.proto -dir . 生成rpc服务 运行服务 go run add.go -f etc/add.yaml 此处会去连接etcd的端口(如果没有etcd的服务就会在这里报错)，具体配置文件在rpc/etc/add.yaml 编写rpc服务（CHECK服务）同上配置 api serverbookstore-api.yaml把rpc服务写入12345678910Add: Etcd: Hosts: - localhost:2379 Key: add.rpcCheck: Etcd: Hosts: - localhost:2379 Key: check.rpc 修改internal/config/config.go如下，增加add/check服务依赖1234567type Config struct &#123; rest.RestConf Add zrpc.RpcClientConf &#x2F;&#x2F; 手动代码 Check zrpc.RpcClientConf &#x2F;&#x2F; 手动代码&#125; 修改internal/svc/servicecontext.go12345678910111213type ServiceContext struct &#123; Config config.Config Adder adder.Adder &#x2F;&#x2F; 手动代码 Checker checker.Checker &#x2F;&#x2F; 手动代码&#125;func NewServiceContext(c config.Config) *ServiceContext &#123; return &amp;ServiceContext&#123; Config: c, Adder: adder.NewAdder(zrpc.MustNewClient(c.Add)), &#x2F;&#x2F; 手动代码 Checker: checker.NewChecker(zrpc.MustNewClient(c.Check)), &#x2F;&#x2F; 手动代码 &#125;&#125; 修改internal/logic/addlogic.go里的Add123456789101112131415func (l *AddLogic) Add(req types.AddReq) (*types.AddResp, error) &#123; &#x2F;&#x2F; 手动代码开始 resp, err :&#x3D; l.svcCtx.Adder.Add(l.ctx, &amp;adder.AddReq&#123; Book: req.Book, Price: req.Price, &#125;) if err !&#x3D; nil &#123; return nil, err &#125; return &amp;types.AddResp&#123; Ok: resp.Ok, &#125;, nil &#x2F;&#x2F; 手动代码结束&#125; 同理修改internal/logic/checklogic.go里的Check12345678910111213141516func (l *CheckLogic) Check(req types.CheckReq) (*types.CheckResp, error) &#123; &#x2F;&#x2F; 手动代码开始 resp, err :&#x3D; l.svcCtx.Checker.Check(l.ctx, &amp;checker.CheckReq&#123; Book: req.Book, &#125;) if err !&#x3D; nil &#123; logx.Error(err) return &amp;types.CheckResp&#123;&#125;, err &#125; return &amp;types.CheckResp&#123; Found: resp.Found, Price: resp.Price, &#125;, nil &#x2F;&#x2F; 手动代码结束&#125; 定义数据库表结构","categories":[],"tags":[]},{"title":"markdown笔记","slug":"markdown笔记","date":"2020-12-30T03:42:00.849Z","updated":"2020-12-30T10:48:10.414Z","comments":true,"path":"2020/12/30/markdown笔记/","link":"","permalink":"http://example.com/2020/12/30/markdown%E7%AC%94%E8%AE%B0/","excerpt":"","text":"插图三种方式12345678910111213基础格式：![Alt text](图片链接 &quot;optional title&quot;)方法一：插入本地图片![avatar](&#x2F;home&#x2F;picture&#x2F;1.png)方法二：插入网络图片![avatar](http:&#x2F;&#x2F;baidu.com&#x2F;pic&#x2F;doge.png)方法三：把图片存入markdown文件![avatar][base64str][base64str]:data:image&#x2F;png;base64,iVBORw0......","categories":[],"tags":[]},{"title":"基础命令日常总结","slug":"linux基础命令","date":"2020-12-29T06:31:08.664Z","updated":"2020-12-30T10:50:33.328Z","comments":true,"path":"2020/12/29/linux基础命令/","link":"","permalink":"http://example.com/2020/12/29/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","excerpt":"","text":"netstat -apn | grep 8080 或者 lsof -i:8080 根据端口查PID netstat -apn | grep 21299 根据PID查端口 kill -9 PID 杀死PID对应的端口 nohup ./main &gt; /dev/null 2&gt;&amp;1 &amp; 后端启动main服务, 并且返回PID号 1234例如：参考链接： https://blog.csdn.net/m0_46657040/article/details/109611803[root@k8s-master-81 harmoryedge]# nohup ./main &gt; /dev/null 2&gt;&amp;1 &amp;[1] 21299 cd /proc/21299 &amp;&amp; ll 通过PID号查询服务路径等信息 npm run start 启动前端start程序(react或者vue)","categories":[],"tags":[]},{"title":"YOU-GET笔记","slug":"you-get笔记","date":"2020-12-25T06:29:11.892Z","updated":"2020-12-30T10:51:36.257Z","comments":true,"path":"2020/12/25/you-get笔记/","link":"","permalink":"http://example.com/2020/12/25/you-get%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考连接 https://github.com/soimort/you-get 安装： brew install you-get 使用 you-get ‘https://www.youtube.com/watch?v=jNQXAC9IVRw&#39; 查看详细信息 you-get -i ‘https://www.youtube.com/watch?v=jNQXAC9IVRw&#39;","categories":[],"tags":[]},{"title":"go测试章节","slug":"gotest测试工具笔记","date":"2020-12-24T12:21:29.025Z","updated":"2020-12-30T10:49:27.756Z","comments":true,"path":"2020/12/24/gotest测试工具笔记/","link":"","permalink":"http://example.com/2020/12/24/gotest%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/","excerpt":"","text":"gotest文本如何书写1234567891011121314151617181920212223242526//表格驱动测试func TestXXX(t * testint.T)&#123; // 定义输入输出 tests := []struct&#123; in int out int &#125;&#125;&#123; // 测试数据 &#123;1, 1&#125;， &#123;2, 2&#125;, ...&#125;for _, tt := range tests &#123; //通过函数执行测试用例 actual := 需要测试的函数名(tt.in) if actual != tt.out &#123; //输出不匹配的信息 //errof输出 t.Errof(t.Errorf(&quot;got %d for input %s; expected %d&quot;, actual, tt.in, tt.out)) //Skipf输出 t.Skipf(t.Errorf(&quot;got %d for input %s; expected %d&quot;, actual, tt.in, tt.out)) //logf输出 t.Logf(t.Errorf(&quot;got %d for input %s; expected %d&quot;, actual, tt.in, tt.out)) &#125;&#125; 表格驱动测试语句（后面通过正则匹配） go test -v -timeout 30s . -run ^TestXXX$ go test 和go tool 性能测试（具体可以通过go tool cover 查询具体命令） go test -coverprofile=cover.out 输出cpu覆盖率 go tool cover -html=cover.out html显示cpu数据 go test -bench xxx.go 目标文件bench性能测试,看花的时间 go pprof测试 go test help help提示信息 go test -bench nonrepeatingsubstr -cpuprofile cpu.out 生成目标文件的cpu使用情况 go tool pprof cpu.out help webpprof交互式显示 godoc 文档 godoc –helpgodoc使用文档 godoc -http :6060服务器形式打开go参考手册","categories":[],"tags":[]},{"title":"初看组件 7大组件+1个运行时（master 5 + node 2）","slug":"kubernetes组件详细笔记","date":"2020-12-18T06:03:37.149Z","updated":"2020-12-30T10:49:52.254Z","comments":true,"path":"2020/12/18/kubernetes组件详细笔记/","link":"","permalink":"http://example.com/2020/12/18/kubernetes%E7%BB%84%E4%BB%B6%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/","excerpt":"","text":"kube-apiserver（1）API 服务器是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。 API 服务器是 Kubernetes 控制面的前端。 Kubernetes API 服务器的主要实现是 kube-apiserver。 kube-apiserver 设计上考虑了水平伸缩，也就是说，它可通过部署多个实例进行伸缩。 你可以运行 kube-apiserver 的多个实例，并在这些实例之间平衡流量。 etcd （2）etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。 您的 Kubernetes 集群的 etcd 数据库通常需要有个备份计划。 要了解 etcd 更深层次的信息，请参考 etcd 文档。 kube-scheduler（3）主节点上的组件，该组件监视那些新创建的未指定运行节点的 Pod，并选择节点让 Pod 在上面运行。 调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。 kube-controller-manager（4）在主节点上运行 控制器 的组件。 从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。 这些控制器包括: 节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应。副本控制器（Replication Controller）: 负责为系统中的每个副本控制器对象维护正确数量的 Pod。端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)。服务帐户和令牌控制器（Service Account &amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌. cloud-controller-manager（5）云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器允许您链接聚合到云提供商的应用编程接口中， 并分离出相互作用的组件与您的集群交互的组件。cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。 与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的 控制回路组合到同一个可执行文件中，供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。 下面的控制器都包含对云平台驱动的依赖： 节点控制器（Node Controller）: 用于在节点终止响应后检查云提供商以确定节点是否已被删除路由控制器（Route Controller）: 用于在底层云基础架构中设置路由服务控制器（Service Controller）: 用于创建、更新和删除云提供商负载均衡器 Node 组件 kubelet（6）一个在集群中每个节点上运行的代理。 它保证容器都运行在 Pod 中。 kubelet 接收一组通过各类机制提供给它的 PodSpecs，确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。 kube-proxy （7）kube-proxy 是集群中每个节点上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。 kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话与 Pod 进行网络通信。 如果操作系统提供了数据包过滤层并可用的话，kube-proxy 会通过它来实现网络规则。否则， kube-proxy 仅转发流量本身。 容器运行时（Container Runtime）（8）容器运行环境是负责运行容器的软件。 Kubernetes 支持多个容器运行环境: Docker、 containerd、CRI-O 以及任何实现 Kubernetes CRI (容器运行环境接口)。 插件（Addons） cattle有集群 DNS Dashboardweb 界面 prometheus容器资源监控 EFK日志监控 node节点开始 节点上的组件包括 kubelet、 容器运行时以及 kube-proxy。 节点于api服务器交互，通过节点上kubectl自注册入集群 子注册参数: 节点生成完成后通过kubeadm join注册12345678910&quot;conditions&quot;: [ &#123; &quot;type&quot;: &quot;Ready&quot;, &quot;status&quot;: &quot;True&quot;, &quot;reason&quot;: &quot;KubeletReady&quot;, &quot;message&quot;: &quot;kubelet is posting ready status&quot;, &quot;lastHeartbeatTime&quot;: &quot;2019-06-05T18:38:35Z&quot;, &quot;lastTransitionTime&quot;: &quot;2019-06-05T11:41:27Z&quot; &#125;] Ready 条件处于 Unknown 或者 False 状态的时间超过了 pod-eviction-timeout, 默认是5分钟，就会被驱逐。","categories":[],"tags":[]},{"title":"连接kubernetes","slug":"kubernetesAPI调用","date":"2020-12-10T06:18:12.992Z","updated":"2020-12-30T10:59:13.914Z","comments":true,"path":"2020/12/10/kubernetesAPI调用/","link":"","permalink":"http://example.com/2020/12/10/kubernetesAPI%E8%B0%83%E7%94%A8/","excerpt":"","text":"client-go 通过client-go获取kubeconfig访问集群 参考文献： https://blog.csdn.net/qq_37950254/article/details/89603207 https://github.com/kubernetes/client-go/blob/master/examples/out-of-cluster-client-configuration/main.go https://kubernetes.io/zh/docs/tasks/administer-cluster/access-cluster-api/ https://my.oschina.net/u/4382516/blog/3303251 普通调用的方法： 123$ kubectl create sa my-sa $ kubect1 create clusterrolebinding my-clusterrolebinding --clusterrole-cluster-admin --serviceaccount=default:my-sa $ export TOKEN=&#x27;kubect1 get secret s(kubect1 get secret | grep my-sa | awk &#x27;(print $l&#125;&#x27;) -ojsonpath=(.data.token&#125; I base64 -d k8s开启http端口 访问apiserver的http8080端口需要开启，apiserver的pod的不安全服务端口 vim /etc/kubernetes/manifests/kube-apiserver.yaml 修改 –insecure-port=8080 定义一个pod最起码的配置12345678910111213141516171819202122232425262728293031323334353637apiVersion: v1kind: Pod （可填 Deployment、Job、Ingress、Service）metadata: name: pod1 namespace: namespace1 labels: mycustome.pod.label: customePodLabel spec: containers: - name: container1 image: xxxdocker镜像 imagePullPolice: IfNotPresent command: 【开启后执行的第一句脚本语言】.sh workingDir: xxx路径[创建工作的内容会这个docker路径下] volumeMounts: - name: 挂载名称1 mountPath: 本地路径 port: - name: portname1 hostport: 本地端口 env: - name: envname1 value: 环境变量值 resource: limits: cpu: 250m memory: 100kb secret: secretName: secretName1 items: - key: k1 path: 容器secret路径 configMap: name: CM1 items: - key: cm1k1 path: 容器configMap路径 综上得，定义一个pod需要 apiversion/ kind/ metadata/ podname/ namespaces/ labels/ containername/ containerimages/ imagePullPolice/ workingdir/ volumeMounts/ name/ mountPath/ port/ name/ hostport/ env/ name value resource/ limits/ cpu/ momory/ secret/ 思路定义pod—&gt;conatiner-&gt;image/port/volume/env/resource 定义一个deployment最起码的配置1234567891011121314151617181920apiVersion: apps/v1kind: Deploymentnamespaces: my-custome-namespacesmetadata: name: 管理指定pod的deploymentspec: replicas: 数量 selector: matchLabels: //通过label选择pod mycustome.pod.label: customePodLabel //label选择器 template: //模版 metadata: labels: mycustome.pod.label: customePodLabel //选择该label的pod spec: containers: //期望创建的容器 - name: nginx image: nginx:1.10 ports: - containerPort: 80 kubectl edit deploy/custome-deployment-nginx 修改deployment kubectl get deployment –show-labels 展示label kubectl rollout status deploy/custome-deployment-nginx 查看发布状态 kubectl rollout history deploy/custome-deployment-nginx 查看历史状态 kubectl rollout undo deploy/nginx-deployment –to-revision=1 回滚到指定版本 kubectl set image deploy/custome-deployment-nginx nginx=nginx:1.11 更新镜像 kubectl scale –replicas=10 deployment/custome-deployment-nginx 扩容 定义一个service最起码的配置123456789101112apiVersion: v1kind: Servicemetadata: name: nginx-service labels: myCustomePodLabel: customePodLabelspec: ports: - port: 88 targetPort: 80 selector: myCustomePodLabel: customePodLabel kubectl edit svc/nginx-service 修改svc配置 k8s调度器，预选策略和优选函数（https://www.cnblogs.com/klvchen/p/10024846.html） 通过手动去实现 需要给指定的node搭上指定公司的label标签，说明属于哪个公司 1kubectl label nodes k8s-master02 type=company02 把pod或者deployment以yaml方式输出 1kubectl get pod zeus-86784767b5-j7hqh -o=yaml pod 状态 三种调度状态：Waiting（等待）、Running（运行中）和 Terminated（已终止） 探针的类型 ExecAction（命令执行）、TCPSocketAction、 HTTPGetAction 两种探针 存活探针、就绪探针 pause容器功能 它提供整个pod的Linux命名空间的基础。 启用PID命名空间，它在每个pod中都作为PID为1进程，并回收僵尸进程","categories":[],"tags":[]}],"categories":[],"tags":[]}